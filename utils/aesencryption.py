"""
AES is a specification for the encryption of electronic data established by
the U.S. National Institute of Standards and Technology (NIST) in 2001.
"""
import os
from Crypto.Cipher import AES

from utils.binary_data_operators import fixed_xor


class AESEncryption(object):
    def __init__(self, key=None, encryption_mode='ECB'):

        self.__key = key if key else self.random_key(16)

        if encryption_mode == 'ECB':
            self.__encryption_mode = AES.MODE_ECB
        elif encryption_mode == 'CBC':
            self.__encryption_mode = AES.MODE_CBC

        self.cipher = AES.new(self.__key, self.__encryption_mode)

    @classmethod
    def new(cls, key, encryption_mode='ECB'):
        return cls(key, encryption_mode)

    def encrypt(self, plain_text):
        return self.cipher.encrypt(plain_text)

    def decrypt(self, cipher_text, iv=None):
        """
        :param cipher_text: bytes
        :return: bytes
        """
        if self.__encryption_mode == AES.MODE_ECB:
            return self.cipher.decrypt(cipher_text)
        elif self.__encryption_mode == AES.MODE_CBC:
            return self.__decrypt_CBC(cipher_text, self.__key, iv)
        return None

    @staticmethod
    def random_key(length):
        """ Return a random generated bytes string of length 'length'. """
        return os.urandom(length)

    @staticmethod
    def __decrypt_CBC(ciphertext, key=None, IV=None):
        """ Arguments must be bytes strings. """
        key = bytes([0] * 16) if not key else key
        IV = bytes([0] * len(key)) if not IV else IV

        block_size = len(key)
        block_count = int(len(ciphertext) / block_size)

        cipher = AES.new(key, AES.MODE_ECB)

        plaintext = b''
        prev_block = IV

        for i in range(block_count):
            block = get_block(ciphertext, block_size, i)
            xored = fixed_xor(cipher.decrypt(block), prev_block)
            plaintext += xored
            prev_block = block

        return plaintext