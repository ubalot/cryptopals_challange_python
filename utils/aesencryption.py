"""
AES is a specification for the encryption of electronic data established by
the U.S. National Institute of Standards and Technology (NIST) in 2001.
"""
import os
from Crypto.Cipher import AES

from utils import converter
from utils.binary_data_operators import fixed_xor


class AESEncryption(object):
    def __init__(self, key=None, encryption_mode='ECB'):

        self.__key = key if key else self.random_key(16)

        if encryption_mode == 'ECB':
            self.__encryption_mode = AES.MODE_ECB
        elif encryption_mode == 'CBC':
            self.__encryption_mode = AES.MODE_CBC

        self.cipher = AES.new(self.__key, self.__encryption_mode)

    @classmethod
    def new(cls, key, encryption_mode='ECB'):
        return cls(key, encryption_mode)

    def encrypt(self, plain_text):
        """AES 128 ECB encryption"""
        padded_plain_text = converter.pkcs7pad(plain_text, 16)
        return self.cipher.encrypt(padded_plain_text)

    def decrypt(self, cipher_text, iv=None):
        """
        :param cipher_text: bytes
        :param iv: bytes
        :return: bytes
        """
        if self.__encryption_mode == AES.MODE_ECB:
            return self.cipher.decrypt(cipher_text)
        elif self.__encryption_mode == AES.MODE_CBC:
            return self.__decrypt_cbc(cipher_text, self.__key, iv)
        return None

    @staticmethod
    def random_key(length):
        """ Return a random generated bytes string of length 'length'. """
        return os.urandom(length)

    @staticmethod
    def __decrypt_cbc(ciphertext, key=None, IV=None):
        """ Arguments must be bytes strings. """
        key = key if key else bytes([0] * 16)
        IV = IV if IV else bytes([0] * len(key))

        block_size = len(key)
        block_count = int(len(ciphertext) / block_size)

        cipher = AES.new(key, AES.MODE_ECB)

        plaintext = b''
        prev_block = IV

        def get_block(buffer, block_size, index):
            return buffer[block_size * index: block_size * (index + 1)]

        for i in range(block_count):
            block = get_block(ciphertext, block_size, i)
            xored = fixed_xor(cipher.decrypt(block), prev_block)
            plaintext += xored
            prev_block = block

        return plaintext